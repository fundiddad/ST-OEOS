// Manages the game state by reading from and writing to the dedicated World Info entries.

import { saveWi, loadWi } from './st-api.js';
import OEOSV4Parser from './v4-parser.js';

/**
 * Updates the World Info entries with a new page generated by the AI.
 * @param {string} id - The ID of the new page.
 * @param {string} content - The OEOScript v4 content of the new page.
 * @param {string} abstract - The text abstract of the new page.
 */
export async function updatePageEntry(id, content, abstract) {
    try {
        // 1. Update Pages
        let pagesEntry = await loadWi('WI-OEOS-Pages');
        if (!pagesEntry || !pagesEntry.entries) {
            pagesEntry = { entries: {} };
        }

        // Create a new entry for the page
        const pageEntry = {
            uid: Date.now(),
            keys: [id, "page", "oeos"],
            content: `<oeos page id="${id}">\n${content}\n</oeos page>`,
            constant: false,
            order: Object.keys(pagesEntry.entries).length,
            enabled: true,
            probability: 100,
            position: 0,
            role: 0
        };

        pagesEntry.entries[pageEntry.uid] = pageEntry;
        await saveWi('WI-OEOS-Pages', pagesEntry);

        // 2. Update Abstracts
        let abstractsEntry = await loadWi('WI-OEOS-Abstracts');
        if (!abstractsEntry || !abstractsEntry.entries) {
            abstractsEntry = { entries: {} };
        }

        const abstractEntry = {
            uid: Date.now() + 1,
            keys: [id, "abstract"],
            content: `${id}: ${abstract};`,
            constant: false,
            order: Object.keys(abstractsEntry.entries).length,
            enabled: true,
            probability: 100,
            position: 0,
            role: 0
        };

        abstractsEntry.entries[abstractEntry.uid] = abstractEntry;
        await saveWi('WI-OEOS-Abstracts', abstractsEntry);

        // 3. Update Graph
        try {
            const pageJson = OEOSV4Parser.toV1(content);
            const gotos = findGotosInCommands(pageJson.pages[Object.keys(pageJson.pages)[0]]);
            if (gotos.length > 0) {
                let graphEntry = await loadWi('WI-OEOS-Graph');
                if (!graphEntry || !graphEntry.entries) {
                    graphEntry = { entries: {} };
                }

                const graphContent = `${id} > ${gotos.join(', ')};\n`;
                const graphUid = Date.now() + 2;
                graphEntry.entries[graphUid] = {
                    uid: graphUid,
                    keys: [id, "graph", "goto"],
                    content: graphContent,
                    constant: false,
                    order: Object.keys(graphEntry.entries).length,
                    enabled: true,
                    probability: 100,
                    position: 0,
                    role: 0
                };
                await saveWi('WI-OEOS-Graph', graphEntry);
            }
        } catch (e) {
            toastr.error(`[OEOS] Failed to parse goto commands for graph update: ${e.message}`);
        }

        // 4. Notify user
        toastr.success(t`OEOS page '${id}' updated successfully!`);
    } catch (error) {
        console.error(`[OEOS] Error updating page entry ${id}:`, error);
        toastr.error(`[OEOS] Failed to update page '${id}': ${error.message}`);
    }
}

/**
 * Recursively finds all goto targets in a command list.
 * @param {Array<Object>} commands - The list of commands to search through.
 * @returns {Array<string>} - A list of unique goto targets.
 */
function findGotosInCommands(commands) {
    let targets = [];
    if (!commands) return targets;

    for (const command of commands) {
        const commandType = Object.keys(command)[0];
        const commandData = command[commandType];

        if (commandType === 'goto') {
            targets.push(commandData.target);
        }
        // Recursively search in nested commands (if, choice options, etc.)
        if (commandData.commands) {
            targets = targets.concat(findGotosInCommands(commandData.commands));
        }
        if (commandData.elseCommands) {
            targets = targets.concat(findGotosInCommands(commandData.elseCommands));
        }
        if (commandData.options) {
            for (const option of commandData.options) {
                if (option.commands) {
                    targets = targets.concat(findGotosInCommands(option.commands));
                }
            }
        }
    }
    // Return unique targets
    return [...new Set(targets)];
}


/**
 * Updates the state entry in World Info based on the player's last action.
 * @param {object} newState - The new state from the OEOS player. e.g., { pageId: 'A1', variables: { hp: 90 } }
 */
export async function updateStateEntry(newState) {
    try {
        let stateEntry = await loadWi('WI-OEOS-State');
        if (!stateEntry || !stateEntry.entries) {
            stateEntry = { entries: {} };
        }

        // Format variables into a compact string: (hp:90,gold:450)
        const variablesString = `(${Object.entries(newState.variables || {})
            .map(([key, value]) => `${key}:${value}`)
            .join(',')})`;

        const newStateString = ` > ${newState.pageId}${variablesString}`;

        // Find existing state entry or create new one
        const existingStateEntry = Object.values(stateEntry.entries).find(entry =>
            entry.keys && entry.keys.includes("state")
        );

        if (existingStateEntry) {
            // Append to existing state
            existingStateEntry.content += newStateString;
        } else {
            // Create new state entry
            const stateUid = Date.now();
            stateEntry.entries[stateUid] = {
                uid: stateUid,
                keys: ["state", "current"],
                content: newStateString,
                constant: false,
                order: 0,
                enabled: true,
                probability: 100,
                position: 0,
                role: 0
            };
        }

        await saveWi('WI-OEOS-State', stateEntry);
    } catch (error) {
        console.error(`[OEOS] Error updating state entry:`, error);
        toastr.error(`[OEOS] Failed to update state: ${error.message}`);
    }
}

