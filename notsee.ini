AI驱动的OEOS,ST前端插件集成。
设想的工作流程：
【选择oeos特定的角色，点击火箭进入oeos 播放器，
oeos 播放器——>加载世界树的pages管理读取pages和上次游戏的进度——>前台：玩家游玩 | 后台：预加载：并发请求不同的故事分支，提前加载游戏page。
】

1.当前角色的pages（json）通过程序新建一个世界树条目（page管理），用于存放pages，该条目永远不会激活（不会被prompt系统写入上下文）；pages来源为chat数组，通过正则表达式查询(<pages> xxxxx </pages> )，轮询。
2.page是由AI生成的
3.预加载，比如当前page为A ，A page可以到（goto）B1 B2 B3  ，检测B能到哪些地方，比如B1到C1 C2 C3 , B2到C4 C5 C6..... 等等。A为当前玩家正在进行的page，为了体验流程，需要至少保持两个page层的预加载，也就是至少到C。 检测当前需要生成后续的page有多少可选择的分支（goto），再排除page管理里面已有的page，然后并发向AI请求




我想实现预加载功能，我会通过提示词让AI生成单个page和他的ID，page会通过goto ID 去到其他page，AI会为每个page生成多个去往的ID，这些ID可能存在，也可能现在不存在.对于不存在的ID，我们需要请求AI生成。
比如当前玩家在page A ，A 可以到（goto）B1 B2 B3（没有） ，检测B能到哪些地方，比如B1到C1 C2 C3 , B2到C4 C5 C6..... 等等。A为当前玩家正在进行的page，为了体验流程，需要至少保持两个page层的预加载，也就是至少到C。 检测当前需要生成后续的page有多少可选择的分支（goto），再排除page管理里面已有的page，然后并发向AI请求。
但是问题是这样非常复杂，其他分支是独立的文件，太庞大了，我不知道怎么实现，怎么管理，怎么读取


不对，OEOS是播放器，不存在打扰一说。是不是可以这样，切换进入不同的分支（jsonl文件），然后生成分支。应该就是树，比如当前为A，创建分支并且请求AI生成page B1，2,3，然后写入世界树，再进入分支B1,2,3重复操作。如果用户在OEOS播放器选择了B2 分支，那B2就成了新的root节点。对不对，这样实现起来困难吗？



我的目标：构建一个无缝的、由AI驱动的动态故事网络

*   **有向图状故事结构**：整个故事是一个由独立的“Page”节点构成的有向图。玩家的每次选择都会沿着这个网络的边移动到下一个节点。
*   **AI驱动生成**：每个Page的内容，包括其ID和它能通向的下一批Page的ID列表（`goto`），都由AI动态生成，充满了无限的可能性。
*   **无缝体验**：为了消除玩家选择分支后的等待时间，系统必须实现一个**智能预加载**机制。当玩家停留在当前Page（例如A）时，系统需要自动、提前生成至少未来两层的所有可能性路径（即A的所有子节点B层，以及所有B层节点的子节点C层）。
*   **动态根节点**：当玩家在OEOS播放器中做出选择并移动到新的Page（例如B2）时，B2就成为故事树的新“根”，预加载系统将从B2开始，重新探索并生成其后续的路径。

数据管理：使用世界书（Lorebook）作为数据库，为当前角色创建一个专用的、**永不激活**的世界书条目（例如，设置一个无法匹配的关键词）。这个条目的内容就是一个大型JSON对象，作为存储所有已生成Page的数据库。扫描AI在聊天中生成的、被特殊标记（如`<pages>...</pages>`）包裹的Page数据，并将其更新到世界书数据库中。


先阅读代码，理解上面说的是什么。理解我的目标是什么，然后清晰的回答我的目标是什么？


在你回答问题前，必须先仔细了解项目逻辑，你不得做任何假设，一切都必须找到依据。
下面可以帮你回答我的问题、了解项目
1先查看世界树相关代码
2再查看OEOS相关代码
3查看聊天记录、聊天分支相关代码
4使用list列出目录，快速定位

**核心挑战**：如何高效地管理一个不断膨胀的、由独立聊天分支（文件）构成的故事网络，并**并发地**在后台生成所有缺失的Page，以确保预加载的效率。


先阅读代码，理解上面说的是什么。思考我的问题，理解我的目标是什么，然后清晰的回答我的目标是什么


现在开始，在做任何设计计划前，都必须先查看代码












1. 我对SillyTavern (ST) 的全部理解
经过对核心代码的深入分析，我理解SillyTavern是一个事件驱动的、高度模块化的Web应用，其核心围绕以下机制构建：

聊天与上下文管理：

核心数据结构: 全局的 chat 数组 (script.js) 是所有交互的基础。它是一个线性的消息对象列表，构成了对话历史。
上下文生成: Generate() 函数是上下文构建的中枢。它会聚合角色卡片信息 (getCharacterCardFields())、经过截断和处理的 chat 历史、世界信息 (getWorldInfoPrompt()) 以及其他注入（如作者笔记），形成一个完整的Prompt发送给AI。任何生成请求，其上下文都直接源于这个线性历史。
分支机制：

Swipes (回复切换): 这是针对单条AI回复的平行版本。数据存储在消息对象的 swipes 数组中，通过 swipe_left() 和 swipe_right() 切换，不改变聊天的主干历史。
Branches (聊天分支): 这是一个更宏观的机制。通过 branchChat() 触发，其本质是创建一个全新的 .jsonl 聊天文件。这个新文件会完整复制父分支从头到分支点的所有聊天记录。通过在元数据中记录父子关系，实现了分支的持久化。上下文的切换是通过修改角色数据中指向当前聊天文件的指针 (characters[this_chid].chat) 并调用 openCharacterChat() 重新加载整个聊天会话来完成的。
数据持久化：

聊天记录: 整个 chat 数组（包括所有swipes）通过 saveChat() 被序列化并保存到与当前会话关联的 .jsonl 文件中。
元数据: 消息的 extra 字段和聊天的 chat_metadata 对象是官方设计的扩展数据存储位置，它们在保存和加载过程中会被完整保留。
后台任务:

generateQuietPrompt() 提供了一种在后台执行生成任务而不影响UI的能力。但其实现严重依赖全局状态（如 is_send_press、streamingProcessor），因此绝对不能并发执行。
2. 我对OEOS的全部理解
OEOS (Open Ended Story) 是一个独立的、基于Vue的前端播放器界面。它本身不处理AI生成或复杂的逻辑，其核心职责是：

可视化故事网络：以图形化的方式向用户展示动态生成的故事图谱。
驱动SillyTavern：当需要生成新的故事节点（Page）时，它通过SillyTavern的事件系统 (eventSource) 发送请求（如 oeos-request-generation）。
接收和展示内容：接收SillyTavern生成完毕的Page数据，并更新其UI。
导航：当用户在图中点击一个节点时，它需要通知SillyTavern切换到该节点对应的聊天分支。
OEOS是“视图层”，而SillyTavern是其背后的“模型与控制层”。

3. 您的目标
您的核心目标是：在SillyTavern中集成OEOS系统，创建一个由AI实时生成、分支可互相连接的动态故事网络（Graph），并通过一套基于SillyTavern原生分支机制的智能预加载方案，彻底消除玩家在探索这个网络时的等待时间，实现无缝的叙事体验。
2. 我对OEOS的全部理解
OEOS (Open Ended Story) 是一个独立的、基于Vue的前端播放器界面。它本身不处理AI生成或复杂的逻辑，其核心职责是：

可视化故事网络：以图形化的方式向用户展示动态生成的故事图谱。
驱动SillyTavern：当需要生成新的故事节点（Page）时，它通过SillyTavern的事件系统 (eventSource) 发送请求（如 oeos-request-generation）。
接收和展示内容：接收SillyTavern生成完毕的Page数据，并更新其UI。
导航：当用户在图中点击一个节点时，它需要通知SillyTavern切换到该节点对应的聊天分支。
OEOS是“视图层”，而SillyTavern是其背后的“模型与控制层”。

3. 您的目标
您的核心目标是：在SillyTavern中集成OEOS系统，创建一个由AI实时生成、分支可互相连接的动态故事网络（Graph），并通过一套基于SillyTavern原生分支机制的智能预加载方案，彻底消除玩家在探索这个网络时的等待时间，实现无缝的叙事体验。

4. 实现方案
基于以上对代码的深入理解和您的明确指示，最终的可行方案如下：

数据结构映射：

OEOS Page <=> SillyTavern Branch: 每一个故事节点（Page）都对应一个独立的 .jsonl 聊天文件。
节点识别: 在每个代表Page的AI消息对象的 extra 字段中，存入一个唯一标识，如 { "oeos_node": true, "page_id": "B1" }。
图结构数据库: 使用一个永不激活的Lorebook条目作为主数据库，存储整个故事图的元数据（所有Page的ID、它们之间的goto关系、以及每个Page对应的.jsonl文件名）。
预加载工作流（串行任务队列）：

触发: 当玩家到达 Page A (chat_A.jsonl) 时，后台触发预加载。
任务入队: 系统为 Page A 的所有子选项（B1, B2...）创建预加载任务，并将它们推入一个串行任务队列。
顺序执行: 一个后台“工人”函数从队列中逐一取出任务并严格按顺序执行，确保不发生并发冲突。对于每个任务（如预加载Page B1）：
创建分支: 调用 createBranch() 从 Page A 的当前消息点创建一个新的分支文件 chat_B1.jsonl。
切换上下文: 调用 openCharacterChat('chat_B1.jsonl') 将SillyTavern的全局上下文切换到这个新分支。
模拟与生成: 在新的上下文中，程序化地“发送”一条代表用户选择的消息，然后调用 generateQuietPrompt() 生成Page B1的内容。
保存内容: 将生成的内容通过 saveReply() 和 saveChatConditional() 写入 chat_B1.jsonl。
恢复上下文: 调用 openCharacterChat('chat_A.jsonl') 将上下文切回玩家所在的原始分支。
更新DB与递归: 更新Lorebook数据库，记录Page B1的信息，并为其子节点（C层）创建新任务加入队列。
分支管理：

导航: OEOS前端负责渲染故事图。用户点击任一节点时，前端调用 openCharacterChat() 并传入该节点对应的 .jsonl 文件名，实现即时跳转。
数据一致性: 保证在预加载任务的第4步（保存内容）和第6步（更新DB）之间操作的原子性，确保文件和数据库同步。
性能: 对于非常庞大的故事网络，未来可引入归档机制，将“冷”分支文件移动到特定目录，并在需要时“唤醒”，以保持主目录的整洁和高性能。


# 背景：
* SillyTavern （以下简称ST）的前端是一个功能强大、高度模块化且极具可扩展性的 Web 应用。它基于传统的 HTML/CSS/JavaScript (jQuery) 技术栈，为用户提供了与 AI 进行深度角色扮演（RP）所需的各种工具。其核心设计思想是“一切皆可配置”，赋予用户极大的自由度来定制交互体验。有提示词、世界树、聊天框架、插件系统（包括正则表达式）等组成。

* OEOS (Open EOS) 是一个独立的、基于Vue的前端播放器界面，通过加载json文件播放，由很多pages组成,每个page有唯一的ID，通过goto id从一个page移动到另一个page，可以组成一个巨大的网络。OEOS的pages必须有一个起点start，然后可以通过启动到达任何page。用户从start开始，通过OEOS的交互界面，可以选择不同的走向（goto不同的page id），也就是在page间跳转。
# AI驱动的OEOS项目简介
* 目标：将OEOS移植为ST的前端插件，并且改造为一个由AI驱动的、动态的、沉浸式的故事平台。

* AI驱动：创建OEOS的专属角色卡和专属提示词，指导AI生成符合故事情节、多分支的（多个goto）、高互动性的、OEOS兼容格式的json page代码。
#  拟实现方案：
## 总体概述：
page本质上是一个有向图
顶点：每个page就是图中的一个顶点，唯一 ID 是顶点的标识。
有向边（Directed Edge）：从当前 page 通过goto id跳转到目标 page 的操作，就是图中一条从 “当前 page 顶点” 指向 “目标 page 顶点” 的有向边。

ST是一个AI聊天平台，当用户发送信息，ST的提示词系统会结合正则表达式、历史记录、世界树等内容，组成上下文发送给AI，得到回复后写入jsonl和通过特殊处理展示给用户，jsonl就是一条一条的、包括了用户和AI交替的聊天记录文件。用户可以通过Branches创建聊天分支，
 聊天分支：这是一个更宏观的机制。通过 branchChat() 触发，其本质是创建一个全新的 .jsonl 聊天文件。这个新文件会完整复制父分支从头到分支点的所有聊天记录。通过在元数据中记录父子关系，实现了分支的持久化。上下文的切换是通过修改角色数据中指向当前聊天文件的指针 (characters[this_chid].chat) 并调用 openCharacterChat() 重新加载整个聊天会话来完成的。
即：这个分支功能是一个多叉树。



## 实现方法

### page生成
目前没有考虑好，有两个想法
1：ST的角色会有一个开场白，新的聊天总是从角色的第一条消息开始，OEOS的start page就放在第一条消息。start有多个有向边，为了生成这些定点，这时就需要要使用分支功能，也就是以start顶点生成N个分支，然后进入每个分支，分别生成下一个顶点，这里记为A1 A2.... 然后将这些page也放入page管理条目（存放在世界树，不会激活，OEOE从这里加载读取page）。这就有了start 指向 A1 A2 。。的有向图，并且每个page都存在。当用户选择某个goto，例如A2， OEOS就在加载进入A2 page ,并且记录行进路线start ->A2,存入世界树的路线条目。A2 可能会指向其他顶点，这就需要在A2查找所有指向的顶点，然后判断是否存在，对于不存在的顶点，在A2创建分支，分别进入分支并且请求AI生成下一个节点。如此往复，就能实现我们的目标。
通过提示词让AI生成page同时也生成page的总结，page总结会构成聊天记录（这里注意，所有AI回复的内容都会写入jsonl，但是展示给用户的是正则表达式后的，page总结是用户看到的聊天记录，也是会被prompt写入上下文的。page用户看不到，但是存在，不会写入上下文。）。发送给AI的内容就保留系统提示词、OEOS提示词 、page的总结记录、世界树、用户行进路线等内容。但是这样的page的总结记录就这样当前分支的，不是全局的。AI应该站在全局来构建故事。并且page的总结记录总是不全面的，AI无法全面了解之前的page是怎么样的，不能记住之前的page，无法和之前page进行互动。
2，不生成总结，依然使用分支功能，对于其他分支上的page，读取世界树的page管理进行补全（也就是新建一个可以激活的世界树，这里根据当前是什么分支而动态的存发其他分支的page）。然后全部发送给AI。但是这样发送的token太多。

### page读取
使用正则表达式读取，然后存入在世界树
### page存放
利用世界树存放，建立一个page存放条目，这个不会激活，OEOE从这里加载读取page



# 当前进度：
仅仅将OEOS移植为插件，可以通过点击输入框旁的按钮进入OESO播放器，加载tease等播放逻辑待修改。
