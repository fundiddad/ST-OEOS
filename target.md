# 项目背景

## 1. SillyTavern (ST) 架构概述

SillyTavern 是一个功能强大、高度模块化的 Web 应用，专为与 AI 进行深度角色扮演（RP）而设计。其核心技术栈为 HTML/CSS/JavaScript (jQuery)，并通过一个事件驱动的架构实现了高度的可扩展性。

*   **核心控制器**: `script.js` 作为应用的中心枢纽，管理着全局状态、核心功能函数和事件总线 `eventSource`。
*   **上下文构建**: `PromptManager.js` 负责动态构建发送给 AI 的最终提示词。它将聊天历史、角色设定、**世界树条目**、作者笔记等多个部分，按照预设的顺序和规则组合成一个完整的上下文。
*   **数据持久化**: 聊天记录以 JSONL 格式存储在后端，通过 `saveChatConditional` 等函数进行持久化。
*   **前端插件系统**: 插件通过监听 `eventSource` 上的事件、操作 DOM 以及与 `script.js` 中暴露的全局对象和服务交互，来将其功能集成到主应用中。

## 2. OEOS (Open EOS) 架构概述

OEOS 是一个基于 Vue.js 2 的独立前端播放器，专门用于解析和渲染 OEOScript——一种为互动故事设计的领域特定语言（DSL）。

*   **页面驱动**: 故事被组织成一个个独立的“页面（Page）”，通过 `goto` 命令实现页面间的跳转，形成非线性的故事网络。
*   **编译执行**: `pageCompiler.js` 负责将 OEOScript v4 脚本编译成 JavaScript 代码，并在一个受限的 `JS-Interpreter` 沙箱环境中安全执行。

# AI 驱动的 OEOS 项目简介

## 目标

将 OEOS 播放器作为 ST 的前端插件进行集成，并将其改造为一个由 AI 动态驱动的、沉浸式、可无限延续的互动故事平台。AI 将扮演“地下城主（Dungeon Master）”的角色，根据玩家的行为实时生成新的故事情节、分支和挑战。

## AI 驱动核心理念

通过创建专属的角色卡和**充分利用 SillyTavern 原生的提示词与世界树系统**，指导 AI 理解当前的故事状态、玩家路径和已知的世界观，从而生成符合 OEOScript v4 格式的、高质量的页面。

# 技术实现方案

## I. 核心原则：充分利用原生 SillyTavern 系统

本方案严格遵循**不重复造轮子**的原则，将完全基于 SillyTavern 成熟的**世界树（World Info）、提示词（Prompt）和正则表达式（Regex）**三大系统进行构建。插件的核心职责是作为 OEOS 播放器与这些原生系统之间的“中间件”和“状态管理器”。

## II. 数据层：世界树（World Info） Schema

我们将创建一系列专门的世界树条目来存储和管理所有游戏数据，并采用**高度紧凑的、非 JSON 的文本格式**以最大化 Token 效率。

1.  **页面存储 (`WI-OEOS-Pages`)**
    *   **用途**: 作为所有 OEOS 页面的主数据库。
    *   **内容**: 存储由 AI 生成的、完整的、保留所有换行和缩进的 **OEOScript v4 格式字符串**。
    *   **激活状态**: **永不激活 (Not Activated)**。此条目仅作为数据仓库，不直接消耗 AI 上下文。
    *   **更新方式**: 由正则表达式在捕获到 AI 生成的 `<oeos page>` 标签后，通过插件 API 进行写入/更新。

2.  **状态与路径 (`WI-OEOS-State`)**
    *   **用途**: 记录玩家自游戏开始以来的**完整行动轨迹**和在**每个节点**上的**全部状态**。
    *   **内容 (紧凑格式)**: 使用 `>` 分隔的路径字符串，每个节点包含页面 ID 和括号包裹的变量状态。
        `start(hp:100,gold:500) > A(hp:100,gold:450) > B(hp:90,gold:450,sex:0)`
    *   **激活状态**: **永远激活 (Always Activated)**。为 AI 提供最关键的、关于“玩家现在在哪”以及“他们是如何带着何种状态到达这里的”的完整记忆。
    *   **更新方式**: OEOS 播放器每进入一个新页面或内部变量变化时，通知插件，由插件更新此条目。

3.  **故事图谱 (`WI-OEOS-Graph`)**
    *   **用途**: 存储已探索页面的连接关系，形成故事的有向图。
    *   **内容 (紧凑格式)**: 使用 `;` 分隔的邻接表表示法。
        `S > A1, A2, A3; A1 > B1, B2, A3; A2 > B2, B3, B4;`
    *   **激活状态**: **永远激活 (Always Activated)**。为 AI 提供故事的宏观结构。
    *   **更新方式**: 当新的页面被生成时，由插件解析其 `goto` 指令并更新此图谱。

4.  **页面摘要 (`WI-OEOS-Abstracts`)**
    *   **用途**: 存储所有页面的文本摘要。
    *   **内容 (紧凑格式)**: 使用 `;` 分隔的键值对。
        `start: 故事的开端...; forest: 你进入了森林...; cave: 你发现了一个阴暗的洞穴;`
    *   **激活状态**: **永远激活 (Always Activated)**。让 AI 能以较低的 Token 成本“速览”大量页面的核心内容。
    *   **更新方式**: 由正则表达式捕获 `<oeos abstract>` 标签后更新。

5.  **动态上下文 (`WI-OEOS-DynamicContext`) - [核心]**
    *   **用途**: 此条目的内容是**动态计算生成**的，它不存储持久数据，而是作为**信息聚合器**。它为 AI 提供生成下一个页面所需的最直接、最详细的参考资料。
    *   **激活状态**: **永远激活 (Always Activated)**。
    *   **构建逻辑**: 当 `WI-OEOS-State` 更新时，插件会**立即触发**以下逻辑来**重写**此条目的全部内容：
        1.  **识别“种子”页面**:
            *   **当前与未来**: 从 `WI-OEOS-State` 获取**当前页面** ID (如 `G2`)，并从 `WI-OEOS-Graph` 获取其所有**子页面** ID (如 `H2, H3, F3, H4`)。
            *   **历史回顾**: 从 `WI-OEOS-State` 获取路径中**最近的 5 个页面** ID (如 `B3, C6, D4, E3, F1`)。
        2.  **扩展历史上下文**:
            *   遍历**历史回顾**中的每一个页面 ID (如 `B3`, `C6` 等)。
            *   在 `WI-OEOS-Graph` 中查找**这些历史页面**的子页面 ID (如 `B3` -> `C6, C1, B1`; `D4` -> `E2, E5, E1` 等)。
        3.  **聚合与提取**:
            *   将以上步骤中收集到的**所有页面 ID**（当前、未来、历史、历史的未来）合并成一个最终列表并去重。
            *   遍历这个最终列表，从 `WI-OEOS-Pages` 数据仓库中，提取出所有**已存在**的页面的**完整 OEOScript v4 源码**。
        4.  **生成最终内容**:
            *   将所有提取出的 OEOScript v4 源码**直接拼接**在一起，形成一个大的代码块，作为 `WI-OEOS-DynamicContext` 的最终内容。这将为 AI 提供一个围绕当前剧情节点的、包含历史路径和未来分支的详细上下文参考。

## III. 核心流程：AI 交互与内容生成

1.  **提示词配置**: 在角色卡的系统提示词中，加入指导 AI 生成 OEOScript v4 语法的指令，并明确要求其使用 `<oeos page>` 和 `<oeos abstract>` 标签包裹输出。（这部分由用户实现）

2.  **正则表达式配置**: 创建两条核心的正则表达式规则：
    *   **规则 A (数据提取)**: 捕获 `id`、页面内容和摘要，调用插件暴露的 API 函数（如 `window.stOeosPlugin.updatePage(id, content, abstract)`）来更新世界树，并将匹配到的 `<oeos page>` 块替换为空字符串。
    *   **规则 B (显示格式化)**: 仅保留 `<oeos abstract>` 的内容并进行美化，使其作为 AI 的回复显示在聊天记录中。

3.  **OEOS 播放器修改**:
    *   **获取页面**: 调用插件的 API（`window.stOeosPlugin.getPage(pageId)`）从 `WI-OEOS-Pages` 中读取页面内容。
    *   **同步状态**: 页面跳转或内部 `Storage` 变量变化时，调用插件 API（`window.stOeosPlugin.updateState(newState)`）上报最新状态。

4.  **插件 (st-oeos-plugin.js) 职责**:
    *   提供启动 OEOS 播放器的 UI 按钮。
    *   向 `window` 对象暴露 API 供 OEOS 和正则表达式调用。
    *   实现 `updateState` 函数：接收 OEOS 传来的状态，**解析并更新** `WI-OEOS-State`，然后**立即触发** `WI-OEOS-DynamicContext` 的**重计算和重写**。
    *   实现 `updatePage` 和 `getPage` 等函数，作为读写世界树数据的统一接口。

## IV. 工作流总结

1.  **启动**: 用户点击按钮，插件启动 OEOS 播放器，并为其提供 `start` 页面。
2.  **互动**: 用户在 OEOS 中与 `start` 页面互动，选择 `goto forest`。
3.  **状态同步**: OEOS 调用 `updateState` 上报新状态。插件接收到后，**将 `> forest(...)` 追加到 `WI-OEOS-State` 字符串末尾**，并立即**重写** `WI-OEOS-DynamicContext` 的内容。
4.  **自动触发**: 在下一次生成请求时，SillyTavern 的 `PromptManager` 自动将所有**激活**的世界树条目（包括刚刚更新的 `State` 和 `DynamicContext`）组合进提示词。
5.  **AI 生成**: AI 获得完整的上下文，生成了 `forest` 页面指向的 `cave` 和 `river` 页面的 OEOScript 代码和摘要。
6.  **正则处理**: 正则表达式捕获到新生成的页面数据，调用插件 API 更新世界树，并只将摘要部分显示在聊天中。
7.  **循环**: 当用户在 `forest` 页面选择 `goto cave` 时，OEOS 再次向插件请求页面，插件从 `WI-OEOS-Pages` 中找到了刚刚由 AI 生成的内容并返回。故事由此无限延续。

# 当前进度

*   已成功将 OEOS 播放器作为 ST 的一个基本插件进行移植。
*   可以通过点击输入框旁的按钮打开 OEOS 播放器界面。
*   播放器已支持加载和播放 OEOScript v4 格式的脚本文件。
